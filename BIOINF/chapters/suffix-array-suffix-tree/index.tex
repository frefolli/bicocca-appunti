\chapter{Suffix Tree e Suffix Array}

\section{Trie}

Un \textbf{Trie} e' un albero ordinato in cui i nodi non mantengono una copia della loro chiave, ma essa e' rappresentata dal cammino radice-nodo.
Infatti ogni arco tra nodi e' etichettato con una stringa.

\paragraph{Esempi}

\subparagraph{esempio semplice}

Un esempio di Trie:

\begin{forest}
    for tree={
      circle,
      black,
      draw,
      fill=blue!30,
      s sep=20mm
    }
      [{}
        [{}, label = A
            [{}, label = B]
            [{}, label = C]
        ]
        [{}, label = B
            [{}, label = A]
            [{}, label = B]
        ]
      ]
\end{forest}

\subparagraph{con dizionario}

Puo' essere generato anche a partire da un dizionario, per esempio:

\begin{align}
    \text{ABE} \\
    \text{ABETE} \\
    \text{ABACO}
    \end{align}
    
    \begin{forest}
        for tree={
          circle,
          black,
          draw,
          fill=blue!30,
          s sep=20mm
        }
          [{}
            [{}, label = A
                [{}, label = B
                    [{}, label = A
                        [{}, label = C
                            [{}, label = O]
                        ]
                    ]
                    [{}, label = E
                        [{}, label = T
                            [{}, label = E]
                        ]
                    ]
                ]
            ]
          ]
    \end{forest}
    
\subparagraph{con terminatori}

Facendo terminare ogni parola del dizionario con un terminatore \$ $\notin \Sigma$, e' possibile costruire un Trie basato su dizionario che indichi chiaramente quali siano le parole del dizionario.
Infatti se il dizionario non gode della prefix-free property, ovvero se $\exists w, x \in \Sigma^*$ tali che $\exists s \in \Sigma^* \mid w \cdot s = x$, il Trie conterra' per $x$ e $w$ due foglie distinte che segnalano la fine delle due parole.
Ovvero per ogni parola nel dizionario sara' presente la rispettiva e distinta foglia corrispondente al terminatore \$.
\begin{align}
\text{ABE\$} \\
\text{ABETE\$} \\
\text{ABACO\$}
\end{align}

\begin{forest}
    for tree={
      circle,
      black,
      draw,
      fill=blue!30,
      s sep=20mm
    }
      [{}
        [{}, label = A
            [{}, label = B
                [{}, label = A
                    [{}, label = C
                        [{}, label = O
                            [{}, label = \$]
                        ]
                    ]
                ]
                [{}, label = E
                    [{}, label = T
                        [{}, label = E
                            [{}, label = \$]
                        ]
                    ]
                    [{}, label = \$]
                ]
            ]
        ]
      ]
\end{forest}

\section{Suffix Tree}

Un \textbf{Suffix Tree} e' un \textbf{Trie} che rappresenta un insieme di suffissi in cui tutti i nodi hanno archi che iniziano con simboli diversi e solo la radice puo' avere meno di due archi.
Ogni nodo contiene come valore la posizione di inizio del suffisso rispetto al testo di partenza.
Un Trie su una stringa $S$ e' generato a partire dall'elenco di tutti i suffissi di $S$ terminati in \$ (quindi un dizionario di lunghezza $|S|$).
Questa struttura dati richiede spazio in memoria con una complessita' di $O(n^2)$.

\paragraph{Esempi}

Un esempio di Suffix Tree per la stringa BANANA\$:

\begin{forest}
    for tree={
        circle,
        black,
        draw,
        fill=blue!30,
        s sep=20mm
    }
      [{}
        [{7}, label = \$]
        [{}, label = A
            [{6}, label = \$]
            [{}, label = NA
                [{4}, label = \$]
                [{2}, label = NA\$]
            ]
        ]
        [{1}, label = BANANA\$]
        [{}, label = NA
            [{5}, label = \$]
            [{3}, label = NA\$]
        ]
      ]
\end{forest}

L'esempio riprende quello dei lucidi del prof. Della Vedova.

\section{Costruzione di Suffix Tree}

\section{Suffix Array}

E' un array di tutti i suffissi di $S$ in ordine lessicografico associati alle rispettive posizioni di inizio nel testo.

\paragraph{Esempi}

Riprendendo il Suffix Tree della sezione precedente e il rispettivo esempio:

\begin{center}
    \begin{tabular}{ ||c c c c c c c c|| }
    \hline
    i & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
    SA & \$ & A\$ & ANA\$ & ANANA\$ & BANANA\$ & NA\$ & NANA\$ \\
    \hline
    \end{tabular}
\end{center}

Possiamo quindi calcolare la Lunghezza del Prefisso Comune ai suffissi utilizzando la formula di ricorrenza: \\*
$Lcp[i] = |CommonPrefix(SA[i], SA[i+1])|$

\begin{center}
    \begin{tabular}{ ||c c c c c c c c|| }
    \hline
    i & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
    SA & \$ & A\$ & ANA\$ & ANANA\$ & BANANA\$ & NA\$ & NANA\$ \\
    LCP & 0 & 1 & 3 & 0 & 0 & 2 & $-$ \\
    \hline
    \end{tabular}
\end{center}

\section{Costruzione di Suffix Array}

TODO

\section{Da Suffix Tree a Suffix Array}

Per creare il Suffix Array e' necessaria una visita depth-first del Suffix Tree in cui i nodi fratelli sono visitati secondo l'ordine lessicografico delle stringhe dei relativi archi uscenti al nodo padre.
Questo processo puo' essere usato per calcolare anche la Lunghezza del Prefisso Comune, modificando la formula usata nella sezione precedente: \\*
$Lcp[i] = NodeDepth(LCA(i, i+1))$, dove $LCA$ e' il Lowest Common Ancestor, trattato piu' avanti.

\section{Da Suffix Array a Suffix Tree}

Innanzitutto si deve disporre del Suffix Array con le informazioni sul LCP.
L'algoritmo si divide in due fasi: 

\begin{itemize}
\item Ricostruzione del Suffix Tree.
\item Riempimento del Suffix Tree.
\end{itemize}

Si consideri quindi la seguente procedura:

\subparagraph{Ricostruzione del Suffix Tree}

Sia dato un array $LCP$.
Se $|LCP| = 0$ allora ritorno una foglia.
Altrimenti creo un nodo e procedo.

Sia quindi $k \in LCP$ l'elemento piu' piccolo in LCP. \\*
Quindi tratto quell'elemento come un separatore. \\

Esempio:

Dato $LCP = [0, 1, 3, 0, 0, 2]$. Il valore piu' piccolo e' $0$, quindi formo i sotto array $<[], [1,3], [], [2]>$ e creo un sottoalbero che come figli i nodi creati dall'applicazione ricorsiva di questa procedura ai singoli sottoarray.

\subparagraph{Riempimento del Suffix Tree}

Per riempire il ST e' sufficiente una visita depth-first in cui si assegnano i valori delle foglie con i valori di SA e i rispettivi archi.

\section{Suffix Tree Generalizzato}

Un \textbf{Suffix Tree Generalizzato} e' un \textbf{Suffix Tree} per un insieme di stringhe.
Ovvero e' Suffix Tree di tutti i suffissi $w$ che appartengono a una delle stringhe.
I nodi saranno decoranti non piu' solo con la posizione nel testo ma con le posizioni nelle relative stringhe, ovvero un insieme di coppie (stringa, posizione). \\*

Il modo piu' semplice per ottenerlo e' la concatenazione delle stringhe con terminali speciali distinti: \\*
$S_{tot} = S_0 \cdot \$_0 \cdot S_1 \cdot \$_1 \cdot ... S_n \cdot \$_n$.

Come esempio, siano $S_0 = MONDIALE$ e $S_1 = CAMBIALE$.
Quindi costruisco $S_{tot} = S_0 \cdot \$_0 \cdot S_1 \cdot \$_1$, ovvero $S_{tot} = MONDIALE \cdot \$_0 \cdot CAMBIALE \cdot \$_1$.

Quindi costruisco il Suffix Tree di $S_{tot}$.
Posso usare il Suffix Tree Generalizzato per cercare la LCS di piu' stringhe al posto di usare un algoritmo banale che avrebbe complessita' temporale $T(S_0,S_1, ... S_n) = \Pi _ {i=0} ^ {n} |S_i|$.

\section{Pattern Matching con Suffix Array}

TODO

\section{Longest Common Substring}

TODO

\section{Lowest Common Ancestor}

TODO