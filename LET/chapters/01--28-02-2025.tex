\chapter{28/02/25}

\section{Stutture Dati}

Le strutture dati utilizzate sono gli alberi, i grafi, le pile, le code.

\section{Algoritmi}

\subsection{Visita Pre}

E' un processo di ereditarieta' => $attr(child) = compute(attr(root))$.

\begin{lstlisting}[language=Python]
def preorder(tree, visit):
  root, children = tree
  visit(root)
  for child in children:
    preorder(child, visit)
\end{lstlisting}

\subsection{Visita Post}

E' un processo di sintesi => $attr(root) = sum([attr(child) for child in children])$.

\begin{lstlisting}[language=Python]
def postorder(tree, visit):
  root, children = tree
  for child in children:
    preorder(child, visit)
  visit(root)
\end{lstlisting}

\subsection{Visita Level}

\begin{lstlisting}[language=Python]
def levelorder(tree, visit):
  Q = Queue([])

  Q.enqueue(tree)
  while len(Q) > 0:
    tree = Q.dequeue()
    root, children = tree
    visit(root)
    for child in children:
      Q.enqueue(child)
\end{lstlisting}

\section{Grafi}

Diagramma di ASSE

\subsection{Depth First}

\begin{lstlisting}[language=Python]
def depthfirst(adiacency, start, visit):
  S = Set({})
  def recursive(src):
    S.add(src)
    visit(src)
    for dst in adiacency[src]:
      if dst not S:
        recursive(dst)
\end{lstlisting}

\subsection{Breadth First}

\begin{lstlisting}[language=Python]
def breadthfirst(adiacency, start, visit):
  S = Set({})
  Q = Queue({start})
  while len(Q) > 0:
    src = Q.dequeue()
    S.add(src)
    visit(src)
    for dst in adiacency[src]:
      if dst not S:
        Q.enqueue(dst)
\end{lstlisting}

\subsection{BackTracking}

Abilita' di rendersi conto che il percorso in profondita' non e' ottimale e quindi tornare sui miei passi per processare altri percorsi.

\begin{lstlisting}[language=Python]
def backtrack(candidate):
  if reject(candidate):
    return
  if accept(candidate):
    output(candidate)
  s = first(candidate)
  while s:
    backtrack(s)
    s = next(candidate)
\end{lstlisting}
